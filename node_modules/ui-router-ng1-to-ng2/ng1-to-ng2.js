var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
(function (factory) {
    if (typeof module === 'object' && typeof module.exports === 'object') {
        var v = factory(require, exports); if (v !== undefined) module.exports = v;
    }
    else if (typeof define === 'function' && define.amd) {
        define(["require", "exports", "angular", "@angular/core", "angular-ui-router", "ui-router-ng2"], factory);
    }
})(function (require, exports) {
    "use strict";
    var angular = require("angular");
    var core_1 = require("@angular/core");
    var angular_ui_router_1 = require("angular-ui-router");
    var ui_router_ng2_1 = require("ui-router-ng2");
    exports.upgradeModule = angular.module('ui.router.upgrade', ['ui.router']);
    var UIViewNgUpgrade = (function () {
        function UIViewNgUpgrade(ref, parent, registry) {
            // From the ui-view-ng-upgrade component's element ref, walk up the DOM two elements...
            // There will first be one ng1 ui-view which hosts this element, and then that ui-view's
            // parent element.  This element has access to the proper "parent viewcontext"
            // The ng2 ui-view is inside this ui-view-ng-upgrade directive, which is inside the ng1 "host" ui-view
            // Both ui-views share the same view context (the view's fqn and created-by-state context information)
            var ng1elem = angular.element(ref.nativeElement).parent().parent();
            // Expose getters for contex and fqn
            Object.defineProperty(parent, "context", {
                get: function () {
                    var data = ng1elem['inheritedData']('$uiView');
                    return (data && data.$cfg) ? data.$cfg.viewDecl.$context : registry.root();
                },
                enumerable: true
            });
            Object.defineProperty(parent, "fqn", {
                get: function () {
                    var data = ng1elem['inheritedData']('$uiView');
                    return (data && data.$uiView) ? data.$uiView.fqn : null;
                },
                enumerable: true
            });
        }
        UIViewNgUpgrade = __decorate([
            core_1.Component({
                selector: 'ui-view-ng-upgrade',
                template: "<ui-view></ui-view>",
                directives: [ui_router_ng2_1.UIROUTER_DIRECTIVES],
                viewProviders: [core_1.provide(ui_router_ng2_1.UIView.PARENT_INJECT, { useValue: {} })],
            }),
            __param(1, core_1.Inject(ui_router_ng2_1.UIView.PARENT_INJECT)), 
            __metadata('design:paramtypes', [core_1.ElementRef, Object, ui_router_ng2_1.StateRegistry])
        ], UIViewNgUpgrade);
        return UIViewNgUpgrade;
    }());
    exports.uiRouterNgUpgrade = {
        setUpgradeAdapter: function (upgradeAdapter) {
            // Downgrade the ng2 Component to an ng1 directive, to be used in a (generated) view
            // template by ui-router, whenever it finds a view with a `component: Ng2ComponentClass`
            exports.upgradeModule.directive("uiViewNgUpgrade", upgradeAdapter.downgradeNg2Component(UIViewNgUpgrade));
            // Register the ng1 DI UIRouter instance as an ng2 Provider
            upgradeAdapter.upgradeNg1Provider('ng1UIRouter', { asToken: ui_router_ng2_1.UIRouter });
            upgradeAdapter.addProvider(core_1.provide(ui_router_ng2_1.TransitionService, { useFactory: function (uiRouter) { return uiRouter.transitionService; }, deps: [ui_router_ng2_1.UIRouter] }));
            upgradeAdapter.addProvider(core_1.provide(ui_router_ng2_1.StateService, { useFactory: function (uiRouter) { return uiRouter.stateService; }, deps: [ui_router_ng2_1.UIRouter] }));
            upgradeAdapter.addProvider(core_1.provide(ui_router_ng2_1.UrlMatcherFactory, { useFactory: function (r) { return r.urlMatcherFactory; }, deps: [ui_router_ng2_1.UIRouter] }));
            upgradeAdapter.addProvider(core_1.provide(ui_router_ng2_1.UrlRouter, { useFactory: function (r) { return r.urlRouter; }, deps: [ui_router_ng2_1.UIRouter] }));
            upgradeAdapter.addProvider(core_1.provide(ui_router_ng2_1.ViewService, { useFactory: function (r) { return r.viewService; }, deps: [ui_router_ng2_1.UIRouter] }));
            upgradeAdapter.addProvider(core_1.provide(ui_router_ng2_1.StateRegistry, { useFactory: function (r) { return r.stateRegistry; }, deps: [ui_router_ng2_1.UIRouter] }));
            upgradeAdapter.addProvider(core_1.provide(ui_router_ng2_1.Globals, { useFactory: function (r) { return r.globals; }, deps: [ui_router_ng2_1.UIRouter] }));
        }
    };
    /**
     * Predicate that returns true if an object is a NG2 Component Class
     */
    function isNg2ComponentClass(def) {
        if (typeof def !== 'function')
            return false;
        if (!Reflect || typeof Reflect['metadata'] !== 'function')
            throw new Error("Missing runtime dependency: 'reflect-metadata'");
        return Reflect['getMetadata']('annotations', def)
            .find(function (x) { return x instanceof core_1.ComponentMetadata; });
    }
    exports.isNg2ComponentClass = isNg2ComponentClass;
    /**
     * Define a stateProvider `views` decorator which applies the standard view builder function,
     * then finds any components which are actually a Ng2 Component Class and overwrites that view config.
     *
     * In place of the template provider, it simply puts a <ui-view-ng-upgrade/> component, which is the
     * downgraded Ng2 Component that provides a ng1-to-ng2 boundary in the DOM.
     */
    exports.upgradeModule.config(['$stateProvider', function ($stateProvider) {
            $stateProvider.decorator('views', function (state, parentFn) {
                var views = parentFn(state);
                ui_router_ng2_1.forEach(views, function (viewDecl, viewName) {
                    if (isNg2ComponentClass(viewDecl.component)) {
                        // Update the view config.
                        // Override default ng1 `component:` behavior (of defining a templateProvider)
                        // with a <ui-view-ng-upgrade> adapter directive template
                        viewDecl.$type = "ng1-to-ng2";
                        viewDecl.templateProvider = null;
                        viewDecl.template = "<ui-view-ng-upgrade></ui-view-ng-upgrade>";
                    }
                });
                return views;
            });
        }]);
    exports.upgradeModule.run(['$view', function ($view) {
            $view.viewConfigFactory('ng2', function (path, config) { return new ui_router_ng2_1.Ng2ViewConfig(path, config); });
            $view.viewConfigFactory('ng1-to-ng2', function (path, config) {
                var ng1ViewConfig = new angular_ui_router_1.Ng1ViewConfig(path, Object.assign({}, config, { $type: 'ng1' }));
                var ng2ViewConfig = new ui_router_ng2_1.Ng2ViewConfig(path, Object.assign({}, config, { $type: 'ng2' }));
                return [ng2ViewConfig, ng1ViewConfig];
            });
        }]);
});
//# sourceMappingURL=ng1-to-ng2.js.map